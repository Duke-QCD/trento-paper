#!/usr/bin/env python
# coding: -*- coding: utf-8 -*-

from __future__ import division, print_function

import functools

import numpy as np
import matplotlib.pyplot as plt


aspect = 1/1.618
resolution = 72.27
columnwidth = 246/resolution
textwidth = 510/resolution
textiny, texsmall, texnormal = 8., 9.25, 10.
offblack = '#262626'

plt.rcdefaults()
plt.rcParams.update({
    'font.family': ['CMU Serif'],
    'font.size': texsmall,
    'legend.fontsize': texsmall,
    'axes.labelsize': texsmall,
    'xtick.labelsize': textiny,
    'ytick.labelsize': textiny,
    'lines.linewidth': .8,
    'patch.linewidth': .8,
    'axes.linewidth': .5,
    'text.color': offblack,
    'axes.edgecolor': offblack,
    'axes.labelcolor': offblack,
    'xtick.color': offblack,
    'ytick.color': offblack,
    'legend.numpoints': 1,
    'legend.scatterpoints': 1,
    'legend.frameon': False,
    'pdf.fonttype': 42
})


def plotfn(f):
    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        print(f.__name__)
        f(*args, **kwargs)
        plt.savefig('{}.pdf'.format(f.__name__))
        plt.close()
    return wrapper


def cleanup(ax=None):
    if ax is None:
        ax = plt.gca()
    for spine in 'top', 'right':
        ax.spines[spine].set_visible(False)
    for ax_name in 'xaxis', 'yaxis':
        getattr(ax, ax_name).set_ticks_position('none')


@plotfn
def saturation():
    plt.figure(figsize=(columnwidth, columnwidth*aspect))

    A = np.linspace(0, 5, 1000)
    B = np.ones_like(A)

    means = (
        ((A+B)/2, 1, 'Arithmetic'),
        (np.sqrt(A*B), 0, 'Geometric'),
        (2*A*B/(A+B), -1, 'Harmonic')
    )

    plt.rc('axes', color_cycle=('#4c72b0', '#55a868', '#c44e52'))

    for M, p, name in means:
        plt.plot(A, M, label='{} ($p = {}$)'.format(name, p))

    plt.xlabel('$a$')
    plt.ylabel('$M_p(a, 1)$')
    plt.xticks(range(6))
    plt.yticks(range(4))
    plt.legend(loc='best')

    cleanup()
    plt.tight_layout(pad=0)


def load_from_cache(fn, unpack=False, usecols=None):
    try:
        return np.load(fn + '.npy')
    except FileNotFoundError:
        arr = np.loadtxt(fn + '.dat', unpack=unpack, usecols=usecols)
        np.save(fn + '.npy', arr)
        return arr


experiment = 'ALICE'


@plotfn
def multdist():
    systems = 'pp', 'pPb', 'PbPb'
    normalizations = .19, .17, .15
    xticks = range(0, 50, 10), range(0, 200, 50), range(0, 3500, 500)
    fig, axes = plt.subplots(ncols=len(systems),
                             figsize=(textwidth, textwidth*aspect/2))

    ax = axes[0]
    system = systems[0]

    for ax, system, norm, xtick in zip(axes, systems, normalizations, xticks):
        ax.set_yscale('log')

        if ax.is_first_col():
            x, y, stat, sys = load_from_cache(
                'data/exp/{}-{}-multdist'.format(experiment, system),
                usecols=(0, 3, 4, 6)
            )[1:].T
            ax.errorbar(x, y, yerr=stat, fmt='',
                        color='.3', capsize=1.2, label=experiment, zorder=10)
            ax.fill_between(x, y+sys, y-sys, color='.5', alpha=.2, zorder=0)

            ax.set_xlim(xmax=50)
            ax.set_ylim(.5*y.min())

            ax.set_ylabel('Probability')
        else:
            xmin, xmax, x, y = load_from_cache(
                'data/exp/{}-{}-multdist'.format(experiment, system),
                usecols=range(4), unpack=True
            )
            ax.plot(x, y/(xmax-xmin), color='.3')

        mult = load_from_cache(
            'data/trento/{}-m0-k0.6-w0.6'.format(system),
            usecols=(3,)
        )
        ax.hist(norm*mult, bins=30, normed=True,
                color='SkyBlue', edgecolor='white', zorder=-1)

        ax.set_xticks(xtick)
        ax.set_yticks([])
        ax.set_xlabel(r'$dN_\mathrm{ch}/d\eta$')
        ax.set_title(system)

        cleanup(ax)

    plt.tight_layout(pad=0, w_pad=.4)


if __name__ == "__main__":
    saturation()
    multdist()
