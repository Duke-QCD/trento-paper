#!/usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import division, print_function

import functools

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.ticker as tick
from scipy import optimize

aspect = 1/1.618
resolution = 72.27
columnwidth = 246/resolution
textwidth = 510/resolution
textiny, texsmall, texnormal = 8., 9.25, 10.
offblack = '#262626'

plt.rcdefaults()
plt.rcParams.update({
    'font.family': ['CMU Serif'],
    'font.size': texsmall,
    'legend.fontsize': 8.5,
    'axes.labelsize': texsmall,
    'axes.titlesize': texsmall,
    'xtick.labelsize': textiny,
    'ytick.labelsize': textiny,
    'lines.linewidth': .9,
    'patch.linewidth': .9,
    'axes.linewidth': .5,
    'text.color': offblack,
    'axes.edgecolor': offblack,
    'axes.labelcolor': offblack,
    'xtick.color': offblack,
    'ytick.color': offblack,
    'xtick.major.size': 2,
    'ytick.major.size': 2,
    'xtick.major.pad': 1.8,
    'ytick.major.pad': 1.8,
    'legend.numpoints': 1,
    'legend.scatterpoints': 1,
    'legend.frameon': False,
    'pdf.fonttype': 42
})

pmean_colors = {
    1: (0.3333333333333333, 0.6588235294117647, 0.40784313725490196),
    0: (0.2980392156862745, 0.4470588235294118, 0.6901960784313725),
    -1: (0.7686274509803922, 0.3058823529411765, 0.3215686274509804)
}


def plotfn(f):
    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        print(f.__name__)
        f(*args, **kwargs)
        plt.savefig('{}.pdf'.format(f.__name__))
        plt.close()
    return wrapper


def despine(ax=None, remove_ticks=False):
    if ax is None:
        ax = plt.gca()
    for spine in 'top', 'right':
        ax.spines[spine].set_visible(False)
    if remove_ticks:
        for ax_name in 'xaxis', 'yaxis':
            getattr(ax, ax_name).set_ticks_position('none')
    else:
        ax.xaxis.set_ticks_position('bottom')
        ax.yaxis.set_ticks_position('left')


@plotfn
def saturation():
    plt.figure(figsize=(columnwidth, .9*columnwidth*aspect))

    A = np.linspace(0, 5, 1000)
    B = np.ones_like(A)

    means = (
        ((A+B)/2, 1, 'Arithmetic'),
        (np.sqrt(A*B), 0, 'Geometric'),
        (2*A*B/(A+B), -1, 'Harmonic')
    )

    for M, p, name in means:
        plt.plot(A, M, color=pmean_colors[p],
                 label='{}: $p = {}$'.format(name, p))

    plt.xlabel('$T_A$')
    plt.ylabel('$T_R(T_A, 1)$')
    plt.xticks(range(6))
    plt.yticks(range(4))
    plt.gca().set_aspect('equal')
    plt.ylim(0, 2.5)
    plt.legend(loc='best')

    despine(remove_ticks=True)
    plt.tight_layout(pad=0)


def load_from_cache(fn, unpack=False, usecols=None):
    try:
        return np.load(fn + '.npy')
    except IOError:
        arr = np.loadtxt(fn + '.dat', unpack=unpack, usecols=usecols)
        np.save(fn + '.npy', arr)
        return arr


experiment = 'ALICE'


@plotfn
def multdist():
    systems = 'pp', 'pPb', 'PbPb'
    energies = 2.36, 5.02, 2.76
    fig, axes = plt.subplots(ncols=len(systems),
                             figsize=(textwidth, textwidth*aspect/2))

    for ax, system, energy in zip(axes, systems, energies):
        ax.set_yscale('log')

        mult = load_from_cache(
            'data/trento/multdist/{}-m0-k0.8-w0.6'.format(system),
            usecols=(3,)
        )

        label = '{} {} TeV'.format(experiment, energy)

        if system == 'pp':
            x, y, stat, sys = load_from_cache(
                'data/exp/{}-{}-multdist'.format(experiment, system),
                usecols=(0, 3, 4, 6)
            )[1:].T
            ax.errorbar(x, y, yerr=stat, fmt='o', markersize=2,
                        markeredgewidth=0, capsize=0, elinewidth=.4,
                        color='.3',
                        label=label
                        )

            norm = (np.inner(x, y) / y.sum()) / mult.mean()
            mult_rescaled = norm*mult
            counts, edges = np.histogram(
                mult_rescaled,
                bins=np.arange(np.max(mult_rescaled)+1),
                density=True
            )
            ax.step(edges[:-1], counts, where='post', color='#55a868',
                    label=r'TRENTO $\kappa = {:.3f}$'.format(norm))

            ax.set_xlim(xmax=52)
            ax.set_ylim(ymin=.45*y.min())

            ax.annotate(r'$|\eta| < 1$, $p_T$ corrected',
                        (.145, .035), xycoords='axes fraction',
                        ha='left', va='bottom')
        else:
            xmin, xmax, x, y = load_from_cache(
                'data/exp/{}-{}-multdist'.format(experiment, system),
                usecols=range(4), unpack=True
            )
            w = xmax - xmin
            z = y/w
            ax.errorbar(x, z, yerr=.06*z, xerr=.035*x,
                        fmt='o', markersize=2, markeredgewidth=0,
                        capsize=0, elinewidth=.4, color='.3',
                        label=label)

            norm = (27.5 if system == 'pPb' else 720.) / mult.mean()
            mult_rescaled = norm*mult
            counts, edges = np.histogram(mult_rescaled, bins=40, density=True)
            ax.step(edges[:-1], 1.22*counts, where='post', color='#55a868',
                    label=r'TRENTO $\kappa = {:.3f}$'.format(norm))

            if system == 'pPb':
                ax.set_xlim(0, 200)

            ax.annotate(r'$|\eta| < 1$, $0.2 < p_T < 3.0$ GeV',
                        (.145, .035), xycoords='axes fraction',
                        ha='left', va='bottom')

        ax.xaxis.set_major_locator(tick.MaxNLocator(4, prune='upper'))
        ax.yaxis.set_major_locator(
            tick.LogLocator(base=10 if system == 'pp' else 100)
        )
        ax.set_xlabel(r'$N_\mathrm{ch}$')
        if ax.is_first_col():
            ax.set_ylabel(r'$P(N_\mathrm{ch})$')
        ax.set_title(system, x=.5, y=.9)

        despine(ax)
        ax.minorticks_off()
        ax.legend(loc=(.02, .12), handlelength=1)

    plt.tight_layout(pad=0, w_pad=.1)


@plotfn
def uranium():
    ilabel = 0
    labels = 'TRENTO U+U', '', 'TRENTO Au+Au', '', '', 'TRENTO fit', '', ''
    files = 'UU_p=0_k=0.7_w=0.5_bcut=3', 'AuAu_p=0_k=0.7_w=0.5_bcut=3'
    markertypes = 'o', '^'
    colors = '#c71487', '#339966'
    cuts = 0.037854, 0.039909
    centralities = 0.001, 0.01
    
    fig, axes = plt.subplots(nrows=2,
                             figsize=(columnwidth, columnwidth*aspect*1.5),sharex=True)

    for centrality, ax in zip(centralities,axes):
        for fn, cut, markertype, plotcolor in zip(files,cuts,markertypes, colors):

            data = load_from_cache(
                'data/trento/uranium/'+fn,
                usecols=(2,3,4)
            )

            # prune data
            cut = centrality/cut 
            N = data.shape[0]
            data = data[data[:,0].argsort()]
            data = data[::-1]
            mult = data[:cut*N,1]
            e2 = data[:cut*N,2]

            # data points with errors
            nbins = 20
            z = mult/mult.mean()
            n, edges = np.histogram(z, bins=nbins)
            middles = (edges[1:] + edges[:-1])/2
            e2avg = np.histogram(z, bins=nbins, weights=e2)[0]/(n+1e-8)
            e2err = np.sqrt(np.histogram(z, bins=nbins, weights=e2*e2)[0]/(n+1e-8))/np.sqrt(n+1e-8)

            # cut to interval (0.9,1.1)
            middles_cut = middles[abs(1-middles[:]) < 0.1]
            e2avg_cut = e2avg[abs(1-middles[:]) < 0.1]
            e2err_cut = e2err[abs(1-middles[:]) < 0.1]
            ax.errorbar(middles_cut, e2avg_cut, yerr=e2err_cut, color=plotcolor, linestyle='none', marker=markertype, markeredgecolor='none',capsize=0, label=labels[ilabel])

            ilabel = ilabel + 1
            
            # optimization
            popt, pcov = optimize.curve_fit(lambda x, a, b: a*x+b, middles_cut, e2avg_cut, p0=None, sigma=e2err_cut)
            xvec = np.linspace(0.9,1.1,1000)
            ax.plot(xvec,popt[1]+popt[0]*xvec,'--', dashes=(6,2), color='grey',linewidth=1.5,label=labels[ilabel])

            #set figure properties
            ax.set_xlim([0.85,1.15])
            ax.set_xticks([0.85,0.9,0.95,1.0,1.05,1.1,1.15])
            ax.set_ylim([0.04,0.18])
            ax.set_yticks([0.04,0.08,0.12,0.16])
            ax.set_ylabel(r"$\varepsilon_2$")

            despine(ax, remove_ticks=True)
            leg = ax.legend(bbox_to_anchor=(0.01, 1.01), loc="upper left", ncol=5, borderaxespad=0., frameon=True, borderpad=0.05)
            leg.get_frame().set_linewidth(0.0)
            ilabel = ilabel + 1

    x = np.linspace(0.85,1.15,1000)
    axes[0].plot(x, -0.526065*x + 0.67,'-',color='#006699', linewidth=1.5)
    axes[0].plot(x, 0.064156*x + 0.0140,'-',color='#006699', linewidth=1.5)
    axes[1].plot(x, -0.263391*x + 0.406,'-',color='#006699', linewidth=1.5, label="MC-Glauber + NBD")
    axes[1].plot(x, 0.039964*x + 0.044,'-',color='#006699', linewidth=1.5)
    leg = ax.legend(bbox_to_anchor=(0.01, 1.01), loc="upper left", ncol=5, borderaxespad=0., frameon=True, borderpad=0.05)
    leg.get_frame().set_linewidth(0.0)

    axes[0].annotate("$0-0.1 \%$ spectators", (.35, .04), xycoords='axes fraction')
    axes[1].annotate("$0-1 \%$ spectators", (.35, .04), xycoords='axes fraction')
    plt.xlabel(r"$N_{ch}/\langle N_{ch} \rangle$")
    plt.tight_layout(pad=0.05)


@plotfn
def eccentricity():
    fig, axes = plt.subplots(nrows=3,
                             figsize=(columnwidth, columnwidth*aspect*1.5))

    bins = 20
    cent_mid = np.linspace(0, 100, bins, endpoint=False) + 50/bins

    for p in 1, 0, -1:
        label = '$p = {}$'.format(p)
        color = pmean_colors[p]

        eccentricity = load_from_cache(
            'data/trento/eccentricity/PbPb_m={}_k=0.8_w=0.6'.format(p),
            usecols=(4, 5)
        ).T.reshape(2, bins, -1)

        for n, (ax, en) in enumerate(zip(axes, eccentricity), start=2):
            ax.plot(cent_mid, en.mean(axis=1), '-',
                    color=color, linewidth=1.0, label=label)
            ax.xaxis.set_major_locator(tick.MaxNLocator(4))
            ax.yaxis.set_major_locator(tick.MaxNLocator(4, prune='upper'))
            ax.set_ylabel(r'$\varepsilon_{}$'.format(n))
            despine(ax, remove_ticks=True)

        ax = axes[2]
        ecc_rms = np.sqrt(np.mean(np.square(eccentricity), axis=-1))
        ax.plot(cent_mid, ecc_rms[0]/ecc_rms[1]**0.6,
                '-', color=color, linewidth=1.0, label=label)
        ax.set_xlim(0, 40)
        ax.xaxis.set_major_locator(tick.MaxNLocator(4))
        ax.set_xlabel('Centrality %')
        ax.set_ylim(0, 1.3)
        ax.yaxis.set_major_locator(tick.MaxNLocator(4, prune='upper'))
        ax.set_ylabel('Ratio')
        despine(ax, remove_ticks=True)

    ratio_data = load_from_cache('data/exp/eccentricity_ratio',
                                 usecols=(0, 1, 2, 3)).T
    cent_mid = ratio_data[:2].mean(axis=0)
    ratio_min, ratio_max = ratio_data[2:]
    ax.fill_between(cent_mid, ratio_min, ratio_max,
                    color='.5', edgecolor='none', alpha=0.4, zorder=-1,
                    label='ALICE')

    axes[-1].legend(loc='best', ncol=3)
    plt.tight_layout(pad=.05)


if __name__ == "__main__":
    saturation()
    multdist()
    uranium()
    eccentricity()
